# -*- coding: utf-8 -*-
"""ACMLab Onboarding Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A4SWVW31z1RT3BgFcMC1cBojsy4Tw5j6
"""

# Commented out IPython magic to ensure Python compatibility.
# this mounts your Google Drive to the Colab VM.
from google.colab import drive
drive.mount('/content/drive', force_remount=True)

# enter the foldername in your Drive where you have saved the unzipped
# workshop folder, e.g. 'acmlab/workshops/week1'
FOLDERNAME = 'acmlab/project/project'
assert FOLDERNAME is not None, "[!] Enter the foldername."

# now that we've mounted your Drive, this ensures that
# the Python interpreter of the Colab VM can load
# python files from within it.
import sys
sys.path.append('/content/drive/My Drive/{}'.format(FOLDERNAME))

# %cd /content/drive/My\ Drive/$FOLDERNAME/

# Commented out IPython magic to ensure Python compatibility.
# Importing the standard ML libraries...
# %load_ext autoreload
# %reload_ext autoreload

import pandas as pd                     # to process our data
import matplotlib.pyplot as plt         # graphing
# from utils import decision_boundary     # for plotting
from sklearn.linear_model import LogisticRegression # our shallow neural network
from PIL import Image


import torch
import numpy as np
import matplotlib.pyplot as plt
import util
import webmercator
import os

zoom = 14.0
longitudes = []
latitudes = []
tile_to_location = {}
for tile in os.listdir("imagery"):
  tile_data = {}
  split_tile = tile.split("_")
  tile_x = split_tile[1]
  tile_y = split_tile[2][:-4]
  lat_tile, lon_tile = webmercator.latlon(float(tile_x), float(tile_y), zoom)
  tile_data["lat"] = lat_tile
  tile_data["lon"] = lon_tile
  tile_to_location[tile] = tile_data
  latitudes.append(lat_tile)
  longitudes.append(lon_tile)

numHeights = 44
height = (max(latitudes)-min(latitudes))/numHeights
print(height)
print(max(latitudes))
print(min(latitudes))
print()
numWidths = 45
width = (max(longitudes)-min(longitudes))/numWidths
print(width)
print(max(longitudes))
print(min(longitudes))

print(tile_to_location)

income_data = pd.read_csv("16zpallnoagi.csv")
geo_data = pd.read_csv("ziplatlon.csv")
for i in range(0, len(geo_data)):
  if (geo_data.state[i] == "CA"):
    lat = geo_data.latitude[i]
    lon = geo_data.longitude[i]

    for tile in os.listdir("imagery"):
      left_lon = tile_to_location[tile]["lon"]
      right_lon = tile_to_location[tile]["lon"] + width
      up_lat = tile_to_location[tile]["lat"]
      down_lat = tile_to_location[tile]["lat"] - height
      
      if ((lon > left_lon and lon < right_lon) and (lat > down_lat and lat < up_lat)):
        tile_to_location[tile]["zip"] = geo_data.zip[i]
      

print(tile_to_location)

for tile in os.listdir("imagery"):
  if ("zip" not in tile_to_location[tile]):
    elevation = util.getElevation(tile_to_location[tile]["lat"], tile_to_location[tile]["lon"])
    centerLat = tile_to_location[tile]["lat"] - height/2
    centerLon = tile_to_location[tile]["lon"] + width/2
    if (elevation != 0):
      curMin = float("inf")
      closestZip = -1
      for j in range(0, len(geo_data)):
        if (geo_data.state[j] == "CA"):
          zipLat = geo_data.latitude[j]
          zipLon = geo_data.longitude[j]
          dist = ((centerLat - zipLat)**2 + (centerLon - zipLon)**2)**0.5
          if (dist < curMin):
            curMin = dist
            closestZip = geo_data.zip[j]
      if closestZip != -1:
        tile_to_location[tile]["zip"] = closestZip
      else:
        print(curMin)
print(tile_to_location)

import csv
with open('tile_to_location.csv', 'w') as f:
    for key in tile_to_location.keys():
        f.write("%s,%s\n"%(key,tile_to_location[key]))

tile_to_income = {}
count = 0
for tile in os.listdir("imagery"):
  if count%1000 == 0:
    print(count)
  if ("zip" in tile_to_location[tile]):
    for k in range(len(income_data)):
      if (income_data.STATE[k] == "CA"):
        if (income_data.ZIPCODE[k] == tile_to_location[tile]["zip"]):
          tile_to_income[tile] = income_data.A02650[k]/income_data.N1[k]
  count += 1
print(tile_to_income)
print()

import json
with open("tile_to_income_annotations.json", "w") as outfile:
    json.dump(tile_to_income, outfile)

from PIL import Image
images = []
labels = []
annotations = {}
for tile in tile_to_income.keys():
  images.append(Image.open(tile).convert("RGB"))
  labels.append(tile_to_income[tile])

